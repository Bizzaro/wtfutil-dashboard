package nextbus

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strconv"

	"github.com/rivo/tview"
	"github.com/wtfutil/wtf/logger"
	"github.com/wtfutil/wtf/view"
)

// Widget is the container for your module's data
type Widget struct {
	view.TextWidget

	settings *Settings
}

// NewWidget creates and returns an instance of Widget
func NewWidget(tviewApp *tview.Application, redrawChan chan bool, pages *tview.Pages, settings *Settings) *Widget {
	widget := Widget{
		TextWidget: view.NewTextWidget(tviewApp, redrawChan, pages, settings.common),

		settings: settings,
	}
	return &widget
}

/* -------------------- Exported Functions -------------------- */

// Refresh updates the onscreen contents of the widget
func (widget *Widget) Refresh() {
	// The last call should always be to the display function
	widget.display()
}

/* -------------------- Unexported Functions -------------------- */

func (widget *Widget) content() string {
	return getNextBus(widget.settings.agency, widget.settings.route, widget.settings.stopID, widget.settings.stopTag)
}

type AutoGenerated struct {
	Predictions Predictions `json:"predictions"`
}

type Prediction struct {
	Minutes string `json:"minutes"`
	Seconds string `json:"seconds"`
}

// Direction struct can hold either a single Direction object or an array of Direction objects
type Direction struct {
	PredictionRaw json.RawMessage `json:"prediction"`
	Title         string          `json:"title"`
}

type Predictions struct {
	RouteTag     string          `json:"routeTag"`
	StopTag      string          `json:"stopTag"`
	RouteTitle   string          `json:"routeTitle"`
	AgencyTitle  string          `json:"agencyTitle"`
	StopTitle    string          `json:"stopTitle"`
	DirectionRaw json.RawMessage `json:"direction"`
}

func getNextBus(agency string, route string, stopID string, stopTag string) string {
	url := ""

	validStopID := len(stopID) > 0
	validStopTag := len(stopTag) > 0

	if validStopID && validStopTag {
		logger.Log("[nextbus] Error: Both stopID and stopTag are specified in config.yml file. Reason: Misconfigured config.yml file")
		return "[nextbus] both stopID and stopTag are specified in config.yml file."
	} else if validStopID {
		url = fmt.Sprintf("https://webservices.umoiq.com/service/publicJSONFeed?command=predictions&a=%s&r=%s&stopId=%s", agency, route, stopID)
	} else if validStopTag {
		url = fmt.Sprintf("https://webservices.umoiq.com/service/publicJSONFeed?command=predictions&a=%s&r=%s&s=%s", agency, route, stopTag)
	} else {
		logger.Log("[nextbus] Error: No stopID or stopTag specified. Reason: Misconfigured config.yml file")
		return "[nextbus] no stopID or stopTag specified."
	}

	resp, err := http.Get(url)
	if err != nil {
		logger.Log(fmt.Sprintf("[nextbus] Error: Failed to make requests to umoiq for next bus predictions. Reason: %s", err))
		return "[nextbus] error calling umoiq"
	}
	defer resp.Body.Close()

	body, readErr := io.ReadAll(resp.Body)
	if readErr != nil {
		logger.Log(fmt.Sprintf("[nextbus] Error: Failed to read response body from umoiq. Reason: %s", readErr))
		return "[nextbus] error reading response body"
	}

	var parsedResponse AutoGenerated
	if err := json.Unmarshal(body, &parsedResponse); err != nil {
		logger.Log(fmt.Sprintf("[nextbus] Error: Failed to unmarshal response from umoiq. Reason: %s", err))
		return "[nextbus] error parsing response body"
	}

	var directions []Direction
	if err := json.Unmarshal(parsedResponse.Predictions.DirectionRaw, &directions); err != nil {
		// If the "direction" field doesn't contain an array, try to unmarshal it as a single Direction object
		var direction Direction
		if err := json.Unmarshal(parsedResponse.Predictions.DirectionRaw, &direction); err != nil {
			logger.Log(fmt.Sprintf("[nextbus] Error: Failed to unmarshal directions from umoiq. Reason: %s", err))
			return "[nextbus] error parsing directions"
		}
		directions = append(directions, direction)
	}

	finalStr := ""
	for _, direction := range directions {
		var predictions []Prediction
		if err := json.Unmarshal(direction.PredictionRaw, &predictions); err != nil {
			logger.Log(fmt.Sprintf("[nextbus] Error: Failed to unmarshal predictions from umoiq. Reason: %s", err))
			return "[nextbus] error parsing predictions"
		}

		for _, prediction := range predictions {
			finalStr += fmt.Sprintf("%s | ETA [%s]\n", parsedResponse.Predictions.RouteTitle, strTimeToInt(prediction.Minutes, prediction.Seconds))
		}
	}

	return finalStr
}

// takes minutes and seconds from the API, does math to find the remainder seconds
// since the API only gives whole minutes
func strTimeToInt(sourceMinutes string, sourceSeconds string) string {
	min, _ := strconv.Atoi(sourceMinutes)
	sec, _ := strconv.Atoi(sourceSeconds)
	sec = sec % 60
	return fmt.Sprintf("%02d:%02d", min, sec)
}

func (widget *Widget) display() {
	widget.Redraw(func() (string, string, bool) {
		return widget.CommonSettings().Title, widget.content(), false
	})
}
